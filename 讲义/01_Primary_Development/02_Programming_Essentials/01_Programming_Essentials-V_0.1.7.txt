
/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * Copyleft (C) 2009-2014
 * COEO - China Open Education Organization
 * "+++New Life+++" Team for Computer Science
 * Free as in freedom. The Truth Will Free You.
 * 张开自由的翅膀，真理要释放你。
 * To teach the inexperienced the ropes 
 * and give our young people a grasp on reality.
 * 教导没有经验的得以丰富，给予青年人开启真理的钥匙。
 * The old life is gone; a new life burgeons!
 * 告别飘逝的过去，拥抱怒放的新生！
 *
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * This file is available to you under a choice of one of two licenses.
 *
 * GPL
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 *
 * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
 * ARE EXPRESSLY DISCLAIMED.
 *
 * See the GNU General Public License * for more details.
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 *
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 
 * BSD
 *
 *  Alternatively you can redistribute this file under the terms of the
 *  BSD license as stated below:
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *  3. The names of its contributors may not be used to endorse or promote
 *     products derived from this software without specific prior written
 *     permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 *  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * Description:
 *     This file describe the Cocos2d programming.
 *
 * Original Date:
 *     Aug-09-2014
 *
 * Modified Date:
  *     Aug-18-2014
 *
 * Authors:
 *     Yuhui    <abrahambenyu@gmail.com>
 *
 * Current Version:
 *     0.1.7
 *
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


00. Table of Contents

    00. Overture
    01. Director, Scenes, and Layers
    02. The Cocos2d Scene Graph
    03. The Node Class Hierarchy
    04. Node
    05. Sprite
    06. LableTTF
    07. Menus
    08. Actions
    09. Orientation, Singletons, Tests, and API References
    10. Conclusion
    11. Homework
    12. Traps and Pitfalls
    13. Diligence


00. Overture

    01. 本章将介绍 Cocos2d 游戏引擎中最基本的一些构成要素，在今后创建的每个游戏中你会经常使用这些类；
    02. 所以，了解哪些类是可用的，并理解它们之间的协作方式，将有助于你编写出更出色的游戏；
    03. 有了这些知识作为基础，你会发现用 Cocos2d 编写游戏比想象中的简单的多；
    04. 由于不同的游戏引擎中，游戏对象的管理方式有在屏幕上的显现方式各不相同；
    05. 因此最好先对 Cocos2d 中每个构成元素的意义以及它们的组合方式有所理解。

01. Director, Scenes, and Layers

    1.00  Overture

          01. Director, Scene 和 Layer 类没有可视化显示；
          02. 它们通常仅供内部使用，作为场景图起点的抽象概念；
          03. 所谓场景图，通常是 Scene 派生对象，Scene 类是场景中其他所有节点的容器；
          04. Layer 也可以用来接收 iOS 设备上的触摸和加速计输入，以及 Mac OS X 上的
              鼠标和键盘输入。

    1.01  The Director

          1.1.01  Introduction

                  01. 导演，每个游戏都是有导演的，导演的责任，他控制着整个游戏的流程，
                      掌握着游戏当中的所有资源，一个游戏当中只能有一个导演；
                  02. Director 类（简称为 Director）是整个 Cocos2d 游戏引擎的核心；
                  03. 回想一下我们的 HelloWorld 程序，就会想起 Cocos2d 中很多初始化过程都包含了
                      Director::getInstance(); 这个调用；
                  04. Director 类是个单例 (singleton)，这意味着任意时刻只能有 Director 类的一个实例，
                      并且通过调用 sharedDirector 方法可以全局访问。

          1.1.02  Major Responsibilities

                  Director 类存储了 Cocos2d 中大量的全局配置信息，用于管理所有的 Cocos2d 场景；
                  Director 类的主要用途包括：

                  01. 访问正在运行的场景；
                  02. 改变场景；
                  03. 存储 Cocos2d 配置信息；
                  04. 访问 Cocos2d 的 OpenGL 视图和窗口；
                  05. 修改 OpenGL 投影及启用深度测试；
                  06. 在 UIKit 和 OpenGL 之间转换坐标；
                  07. 暂停、恢复以及终止游戏；
                  08. 显示调试信息；
                  09. 统计渲染的总帧数；

                  Cocos2d 以前的版本中，有几种 Director 类型可供选择，但是在 Cocos2d 2.0 中，
                  情况发生了变化；
                  Director 现在只使用苹果公司的 CADisplayLink 类来同步屏幕更新和显示屏的刷新率。

    1.02  Scene

          1.2.01  Introduction

                  01. SCene 对象往往是场景图中的第一个节点，Cocos2d 中的场景是抽象的概念；
                  02. 与 Node 相比，Scene 类基本上没有包含额外的代码；
                  03. 但是 Director 要求有一个派生自 Scene 的类，这样才能够通过 Director 的
                      runWithScene, replaceScene 和 pushScene 方法修改当前活动的场景图；
                  04. 也可以把 Scene 类封装到派生自 SceneTransition 的类中，以便能够在当前运行
                      的场景和下一个场景进行切换时使用动画加以显示。

          1.2.02  Description with Code

                  01. 通常，Scene 唯一的子类是从 Layer 继承的类，这些类又包含单独的游戏对象，
                      不过 Cocos2d 并不强制要求这么做；
                  02. 因为大多数时候场景对象本身并不包含具体的游戏代码，而且基本上不会从它们派生子类；
                  03. 首先，在 applicationDidFinishLaunching 方法的结尾创建场景，使用 Director
                      类的 runWithScene 方法启动第一个场景：
                      // run
                      pDirector->runWithScene(pScene);
                  04. 对于以后的场景变化，必须使用 replaceScene 方法替换现有的场景：
                      // use replaceScene to change all subsequent scenes
                      pDirector->replaceScene(newScene);
                  05. 在稍后你将会看到，在替换场景时可以使用过渡效果，下面的例子使用
                      Transition-ShrinkGrow 作为中间场景来管理过渡动画。

    1.03  Scenes and Memory
    
          01. 当进行场景替换时，新场景往往在旧场景释放前就被加载到内存中了，这会导致内存负荷瞬间增大；
          02. 所以，场景替换是最容易引发内存警告或者干脆导致程序崩溃的；
          03. 当你的游戏使用大量使用内存时，就应该尽量多地对场景切换的情况进行测试。

    1.04  Pushing and Popping Scenes
    
          1.4.01  Introduction
          
                  01. 在讨论场景替换的同时，我还要提一下 pushScene 和 popScene 这两个有用的方法，
                      这两个方法用来在不释放旧场景内存的情况下运行新场景；
                  02. 如果把场景看成一些纸张，那么
                      推进一个场景就像是在当前可见纸张上放一张新纸；原来的纸张保持位置不变，并且仍然
                      保留在内存中，而不是被替换；对于每个被推进的场景，后面要调用 popScene（作用就
                      像是拿走最顶端的一张纸），直到只剩下最初的场景；
                  03. 这么做的目的是加快场景切换，不过这里有个令人头疼的问题：如果新旧两个场景对内存需
                      求都不大，可以共享内存，那么无论如何它们切换起来都是很快的；但如果场景都非常复杂，
                      加载起来很慢，那么使用 pushScene 和 popScene 以后，这两个场景互相争夺宝贵的
                      内存资源，内存使用很快就会达到非常危险的级别。
          
          1.4.02  Conundrum
          
                  01. 使用 pushScene 和 popScene 最大的问题在于需要跟踪推进了多少个场景，以保证弹出
                      正确数量的场景；
                  02. 只要稍不留意，就可能忘记弹出场景，或者对于同一场景弹出太多遍，更
                      可怕的是，所有这些场景都共享着同一块内存。
          
          1.4.03  Change Music and Sound Volume
          
                  01. 如果一个场景在很多地方被用到，那么使用 pushScene 和 popScene 会非常方便，用来
                      调节音量和选择背景音乐的 Settings 场景就是一个很好的例子；
                  02. 可以推进 Settings 场景来显示它，当按下 Settings 场景中的返回按钮时，调用 popScene
                      就可以返回到显示 Settings 场景前的情形；
                  03. 不论 Settings 场景是在主菜单中、游戏过程中还是在其他地方打开，pushScene 和 popScene
                      都是适用的，而且开发者还不用时刻关心 Settings 场景是在哪里被打开的。
          
          1.4.04  Retain the State of the Initial Scene
          
                  01. 当想要保留最初场景的状态，而不想保留和加载状态时，pushScene 和 popScene 也很有用；
                  02. 例如，可以推进一个显示多人游戏当前排行榜的场景，并在以后弹出它，游戏场景会保存在内存
                      中，所以整个过程并不需要保存和加载游戏状态；
                  03. 在玩家查看排行榜的过程中，游戏不会继续进行，因为在排行榜场景显示的过程中，游戏场景会
                      初自动暂停；
                  04. 但是，每当可以推进场景时，需要保证总是有足够的额外内存可供推进的场景使用，但是这一点
                      很难测试，建议要推进的任何场景都应该是轻巧的，只占用很少的内存，并且只弹出自身，而不
                      会推进其他场景，甚至调用 replaceScene。

          1.4.05  Source Code - replaceScene()

                  这个我们要建立一个场景的类来处理更方便，给出部分代码，剩余部分留为作业。

                  auto gameOverScene = GameOverScene::create();
                  gameOverScene->getLayer()->getLabel()->setString("You Lose :(");
                  Director::getInstance()->replaceScene(gameOverScene);

    1.05  TransitionsScene
    
          1.5.01  Introduction
          
                  01. 场景过渡就是任何从 TransitionScene 继承的类，它们可以让你的游戏看起来非常专业；
                  02. 图 TransitionScene_Class_Hierarchy 概览了类的层次结构，并显示了可用的过渡类；
                  03. 在前面的图 Node_Class_Hierarchy 中，为了简洁起见，没有包含 TransitionScene
                      的子类，所以此图可以当作 Node_Class_Hierarchy 的补充。
          
          1.5.02  Usage
          
                  01. 要使用过渡效果，只要在场景转换时添加一行代码就可以做到（虽然我不得不承认，那一行代码
                      可能是很长很长的一行，这取决于过渡效果的名称长度以及所需参数的个数）；
                  02. 这里我列举一个觉的淡入淡出过渡的例子，它会在一秒内过渡到纯白背景，代码如下：
                      // create a scene.
                      Scene* pGameScene = Scene::create();
                      Genesis* pGenesisScene = Genesis::create();
                      pGameScene->addChild(pGenesisScene);
                      pDirector->setDepthTest(true);
                      // initialize a transition scene with the scene we'd like to
                      // display next
                      //TransitionFade* tran = TransitionFade::create(1, pGameScene, Color3B::WHITE);
                      TransitionPageTurn* turn = TransitionPageTurn::create(2, pGameScene, false);
                      // use the transition scene object instead of GameLayer
                      pDirector->replaceScene(turn);
                  03. 可以把 TransitionScene 与 replaceScene 和 pushScene 结合起来使用，但是，正如
                      我前面说过的，过渡效果不和和 popScene 一起使用（至少现在是这样的，未来的 Cocos2d
                      版本中可能会有所改变）。
          
          1.5.03  Variety of Transitions
          
                  Cocos2d 中有很多过渡效果可供使用，虽然很多只是在方向上有所变化，比如过渡从哪边开始，信哪
                  个方向扩展等；下面来列出现有的过渡效果，并对每个效果做一些简单描述：
          
                  01. TransitionFade，淡入淡出到某个指定了颜色的背景，然后恢复，
                      还有另一个版本为 TransitionCrossFade；
                  02. TransitonFadeTR（还有其他 3 种版本），瓦片翻转，渐渐显示新场景；
                  03. TransitionJumpZoom，旧场景弹跳着缩小，新场景弹跳着放大；
                  04. TransitionMoveInL（还有其他 3 种版本），旧场景移出，同时新场景从任意方向移入；
                  05. TransitionSceneOriented（还有其他 6 种版本），整个场景会绕其一个轴翻转过来；
                  06. TransitionPageTurn，翻页效果；
                  07. TransitionProgress（还有其他 6 种版本），类似于雷达屏幕，使用雷达或轴对齐扫描
                      动画显示新场景；
                  08. TransitionRotoZoom，旧场景边旋转边缩小，新场景边旋转边放大；
                  09. TransitionShrinkGrow，旧场景缩小，新场景在旧场景基础上放大；
                  10. TransitionSlideInL（还有其他 3 种版本），新场景从各个方向掠过旧场景；
                  11. TransitionSplitCols（还有另一种版本），旧场景切成竖条，从上方或下方散开，新场景显现；
                  12. TransitionTurnOffTiles，新场景呈瓦片状替代旧场景。

    1.06  Layer

          1.6.01  Introduction

                  01. 有时候你的场景中需要不止一个层，这时可以在场景中添加更多的 Layer 对象；
                  02. 一种方法是直接在 scene 方法中完成：
                      Scene* GameLayer::scene()
                      {
                          // 'scene' is an autorelease object
                          Scene *scene = Scene::create();

                          // 'layer' is an autorelease object
                          GameLayer *backgroundLayer = GameLayer::gameBackground();
                          // add layer as a child to scene
                          scene->addChild(backgroundLayer);

                          GameLayer *layer = GameLayer::GameLayer();
                          scene->addChild(layer);

                          GameLayer *userInterfaceLayer = GameLayer::GameUserInterface();
                          scene->addChild(userInterfaceLayer);

                          // return the scene
                          return scene;
                      }
                  03. 这个场景现在有 3 个不同的层：backgroundLayer, 普通的游戏对象层和 userInterface；
                  04. 因为层是按照创建顺序添加的，所以添加到 backgroundLayer 的任意节点会在其他层之后绘制；
                  05. 另外，严格来说，层不一定要从 Layer 类派生，它也可以是简单的 Node，当只需要用层
                      来组织节点，而不需要它们处理输入时，这通常是更好的办法。

          1.6.02  Touch Events

                  1.6.2.01  Introduction

                            01. Layer 类是被设计为可以接收触摸输入的，但是需要显示地启用这个功能；
                                这个是通过 this->setTouchEnabled(true); 实现的；
                            02. 这个操作最好在类的 init 方法中完成，但是可以在其他任何地方对其进行修改；
                            03. 一但 isTouchEnabled 属性被设置好，许多用来接收触摸输入的方法就都会被调用；
                            04. 以下列出触摸开始、手指在屏幕上移动以及手指离开屏幕时会接收到的事件。

                  1.6.2.02  Methods

                            01. 当单指接触到屏幕时被调用：
                                listener->onTouchesBegan =
                                    CC_CALLBACK_2(InputDelegate::onTouchesBegan, this);
                            02. 当手指在屏幕上移动时被调用：
                                listener->onTouchesMoved =
                                    CC_CALLBACK_2(InputDelegate::onTouchesMoved, this);
                            03. 当单指离开屏幕时被调用：
                                listener->onTouchesEnded =
                                    CC_CALLBACK_2(InputDelegate::onTouchesEnded, this);
                            04. 当触摸取消时被调用：
                                listener->onTouchesCancelled =
                                    CC_CALLBACK_2(InputDelegate::onTouchesCancelled, this);
                            05. 取消事件一般很少发生，所以大多数情况下它的行为和触摸结束类似。

                  1.6.2.03  Location

                            这部分代码等到稍后的 Mouse Events 实现后，再过来研究；

                            bool GameLayer::onTouchBegan(cocos2d::Touch *touch,
                                                         cocos2d::Event *event)
                            {
                                CCLOG(" +++++ onTouchBegan(). +++++");
    
                                auto touchPoint = touch->getLocation();

                                CCLOG("touchPoint.x = %f", touchPoint.x);
                                CCLOG("touchPoint.y = %f", touchPoint.y);

                                return true;
                            }

          1.6.03  Accelerometer Events

                  01. isAccelerometerEnabled() 返回是否启动加速计：
                      /// isAccelerometerEnabled getter
                      bool Layer::isAccelerometerEnabled() const
                      {
                          return _accelerometerEnabled;
                      }
                  02. setAccelerometerEnabled() 设置启动和关闭加速计：
                      /// isAccelerometerEnabled setter
                      void Layer::setAccelerometerEnabled(bool enabled)
                  03. onAcceleration() 是加速计被调用时执行的函数：
                      void Layer::onAcceleration(Acceleration* acc, Event* unused_event)
                  04. 同学们来查找我上面讲的几个函数在源代码中的实现。

          1.6.04  Keyboard Events

                  01. 如果是创建 Mac OS X 应用程序，就需要处理按键操作，首先需要启用键盘事件：
                      /// isKeyboardEnabled getter
                      bool Layer::isKeyboardEnabled() const
                      {
                          return _keyboardEnabled;
                      }
                      /// isKeyboardEnabled setter
                      void Layer::setKeyboardEnabled(bool enabled)
                      {
                          if (enabled != _keyboardEnabled)
                          {
                              _keyboardEnabled = enabled;
                              // …
                      }
                  02. 用户按下或释放修改键时，无论他是否同时按下了其他任何键，都会接收到标志更改事件，
                      可以使用事件实现对修改键的直接控制。

          1.6.05  Mouse Events

                  01. 与其他输入方法一样，必须首先启用鼠标输入，我查看了一下 Cocos2d-x 源代码，
                      CCLayer.cpp 里没有设置，手机嘛，没有鼠标很应当，如果想要得自己来实现一下；
                  02. 如果设置了，层就应该开始接收数量众多的 MouseEvent 消息，请看源代码：
                      bool EventListenerMouse::init()
                      {
                          auto listener = [this](Event* event){
                              auto mouseEvent = static_cast<EventMouse*>(event);
                              switch (mouseEvent->_mouseEventType)
                              {
                                  case EventMouse::MouseEventType::MOUSE_DOWN:
                                      if(onMouseDown != nullptr)
                                          onMouseDown(event);
                                      break;
                                  case EventMouse::MouseEventType::MOUSE_UP:
                                      if(onMouseUp != nullptr)
                                          onMouseUp(event);
                                      break;
                                  case EventMouse::MouseEventType::MOUSE_MOVE:
                                      if(onMouseMove != nullptr)
                                          onMouseMove(event);
                                      break;
                                  case EventMouse::MouseEventType::MOUSE_SCROLL:
                                      if(onMouseScroll != nullptr)
                                          onMouseScroll(event);
                                      break;
                                  default:
                                      break;
                              }
                          };

                          if (EventListener::init(Type::MOUSE, LISTENER_ID, listener))
                          {
                              return true;
                          }

                          return false;
                      }
                  03. 由于每个鼠标按键都有对应的事件，因此 Event 主要用于获取鼠标光标的当前位置，必须使用
                      Director 的 convertToGL 方法将光标位置转换为 Cocos2d 坐标。

          1.6.06  Source Code - onTouchBegan()

                  1.6.6.01  GameLayer.h

                            bool onTouchBegan(cocos2d::Touch* touch, cocos2d::Event* event);

                  1.6.6.02  onTouchBegan() in GameLayer.cpp

                            bool GameLayer::onTouchBegan(cocos2d::Touch* touch,
                                                         cocos2d::Event* event)
                            {
                                CCLOG(" +++++ onTouchBegan(). +++++");
                                return true;
                            }

                  1.6.6.03  Building, Troubleshooting, Thinking

                            01. 查看打印结果，是否有我们的触摸结束事件产生？
                            02. 为什么没有呢？是不是没有设置触发事件！

                  1.6.6.04  GameLayer.h

                            virtual void onEnter();

                  1.6.6.05  onEnter() in GameLayer.cpp

                            void GameLayer::onEnter()
                            {
                                Layer::onEnter();

                                auto listener = EventListenerTouchOneByOne::create();
                                listener->setSwallowTouches(true);

                                listener->onTouchBegan = CC_CALLBACK_2(GameLayer::onTouchBegan, this);
                                _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this);
                            }

                  1.6.7.06  Building, Troubleshooting, Thinking

                            查看打印结果，是否有我们的触摸结束事件产生？

          1.6.07  Source Code - onTouchEnded()

                  同学们练习，把 onTouchEnded() 的实现做出来！

02. The Cocos2d Scene Graph

    2.01  Introduction

          01. 场景图，有时也称为场景层次体系，是当前所有活跃 Cocos2d 节点的层次关系；
          02. Cocos2d 节点都是 Node 类派生出来的对象，大多数节点，比如 Sprite 和 LabelTTF，
              要显示在屏幕上，但有些是没有视觉效果的，其中包括 Node, Scene 和 Layer；
          03. 暂时你只需要知道 Sprite 类用来在屏幕上显示纹理，LabelTTF 用于打印一段任意文本，
              以及 Node, Scene 和 Layer 用于将节点组合在一起。

    2.02  Illustrations

          2.2.01  A Shoot 'em Up Game

                  01. 图 "A_Shoot_'em_up_Game" 中的场景全部是用 Sprite 对象制作的，至少你能
                      看到的都是；
                  02. 无法看见的是 Scene 和 Layer 类如何将这些不同的精灵有序地组合起来的过程，
                      这些精灵是一些背景层，玩家操纵的船、敌军、子弹以及虚拟手柄和按钮；
                  03. 为了说明这个场景中元素的层关系，下图展示了场景中画面的解剖视图。

          2.2.02  Exploded View Drawing of that Scene

                  01. An_Exploded_View_Illustrating_a_Typical_Cocos2d_Game_Scene_Layout
                      是典型 Cocos2d 游戏场景布局的解剖视图；
                  02. 在这一特定场景中，背景层、游戏对象层、虚拟操作层这三个层对象起到了维护相互联系的
                      精灵之间的合适绘图顺序的作用；
                  03. 运用多层场景还有一个好处，就是方便隐藏整个层中的节点，删除层就可以删除该层包括的
                      所有节点，重新提排布局的顺序就可以改变节点绘制在其他层之上或之下；
                  04. 还可以旋转和缩放单个层，这样就能旋转和缩放层中所有节点，这些功能使层变得强大有效；
                  05. 就像层是节点的容器一样，实际的场景对象就是所有层（也可以说是实际图像）的容器；
                  06. 场景、层、独立节点、精灵、标签等等，每一个节点都可以运行自定义的游戏逻辑，保存于
                      你组织代码的方式。

    2.03  Node

          2.3.01  Introduction

                  01. 任何节点都可以将其他节点作为子节点，并且所有层次体系中的节点，除了场景本身，都有父
                      对象，也就是说节点是父对象的孩子；
                  02. 如果把节点从场景中删除，或者还没有添加节点，那么节点就还没有父对象；
                  03. 注意，不要将父节点关系和面向对象编程中的继承弄混淆，换句话说，父节点不是子节点的父亲；
                  04. 创建的节点树型层次体系就是所谓的场景图，偶尔也称作节点层次体系；
                  05. 对于熟悉编程设计模式的开发者来说，可以把这种层次结构视作组合设计模式。

          2.3.02  The Node Hierarchy

                  01. Node_Hierarchy_of_the_Scene_Illustrated 展示了本场景最简单的树型结构节点
                      层次体系；
                  02. 注意，除了场景图总是必须以场景类对象作为节点以外，Cocos2d 并没有强调必须要有这样一个
                      场景/层/节点结构；
                  03. 除此之外，可以用任意 Node 类代替 Layer 来创建 "层"；
                  04. 甚至可以将所有节点添加到场景中去，如果你的项目只有少量节点的话，这样做完全合乎情理。

    2.04  Node as Layer

          01. 我一般倾向于使用简单的 Node 类而不是 Layer 来做层处理和组织对象；
          02. 大多数情况，Layer 类会添加不必要的开支，因为它包含了一些代码来在 iOS 应用中接收触摸和加速计
              的输入，以及处理在 Mac OS X 应用程序中的键盘和鼠标输入；
          03. 除去对输入处理的支持，Layer 类实际上就是一个 Node 类；
          04. Scene 也一样，同样只是一个为了强制统一根节点的抽象概念；
          05. 否则 Scene 类实际上也就是一个 Node 类。

03. The Node Class Hierarchy

    01. 现在，你可能在想都有哪些类从 Node 派生；
    02. 图 "Node_Class_Hierarchy" 显示了 Node 类的层次结构；
    03. 其中最常用的类已经用阴影标出，使用它们已足以制作出色的游戏。

04. Node

    Node 是所有节点的基类，它是一个没有具体显示的抽象类，仅用于定义所有节点的公共属性和方法。

    4.01  Working with Nodes

          4.1.01  Create a New Node

                  Node * Node::create()
                  {
                      Node * ret = new Node();
                      if (ret && ret->init())
                      {
                          ret->autorelease();
                      }
                      else
                      {
                          CC_SAFE_DELETE(ret);
                      }
	                  return ret;
                  }

          4.1.02  Add the New Node as a Child

                  // add layer as a child to scene
                  scene->addChild(layer);

          4.1.03  Retrieve the Child Node

                  Node *child = this->getChildByTag(tag);

          4.1.04  Remove the Child Node by Tag

                  removeChildByTag(kSceneRadial, true);

          4.1.05  Remove the Node by Pointer

                  void Node::removeChildByName(const std::string &name, bool cleanup)
                  {
                      CCASSERT(name.length() != 0, "Invalid name");

                      Node *child = this->getChildByName(name);
    
                      if (child == nullptr)
                      {
                          CCLOG("cocos2d: removeChildByName(name = %s): child not found!", name.c_str());
                      }
                      else
                      {
                          this->removeChild(child, cleanup);
                      }
                  }

          4.1.06  Remove Every Child of the Node

                  void Node::removeAllChildren()
                  {
                      this->removeAllChildrenWithCleanup(true);
                  }

          4.1.07  Remove myNode from its Parent

                  void Node::removeFromParent()
                  {
                      this->removeFromParentAndCleanup(true);
                  }

    4.02  Working with Actions

          4.2.01  Introduction

                  节点也可以运行动作，你只要知道动作是指在特定时间内完成移动、旋转、缩放以及其他操作的一些行为。

          4.2.02  Action Declaration

                  // 生成动作对象
                  MoveTo* pMoveTo = MoveTo::create(2, Point(300, 300));

          4.2.03  Running Action

                  pSprite->runAction(pMoveTo);

          4.2.04  Access Action by Tag

                  Action *action = getActionByTag(kZoomActionTag);
                  if (action)
                  {
                      stopAction(action);        
                  }

          4.2.05  Stop Action by Tag

                  // Implementation, Node.cpp
                  void Node::stopActionByTag(int tag)
                  {
                      CCASSERT( tag != Action::INVALID_TAG, "Invalid tag");
                      _actionManager->removeActionByTag(tag, this);
                  }

                  // Method Call
                  this->stopActionByTag(kZoomActionTag);

          4.2.06  Stop Action by Pointer

                  Action *action = getActionByTag(kZoomActionTag);
                  if (action)
                  {
                      stopAction(action);
                  }

          4.2.07  Stop all Actions

                  void Node::cleanup()
                  {
                      // actions
                      this->stopAllActions();
                      this->unscheduleAllSelectors();

                      // ... ...
                  }

    4.03  Scheduled Methods

          4.3.01  Introduction

                  01. 节点可以对方法进行调度，其实就是指程序中每隔一段时间调用一次方法；
                  02. 很多情况下，也很可能想对某个节点采用特定的更新方法来进行某个操作，例如碰撞检测。

          4.3.02  scheduleUpdate()

                  01. 要使特定的更新方法以每帧的频率被调用一次，最简单的做法如下所示；
                      this->scheduleUpdate();
                  02. 这行代码出现在节点的 init 方法中。

          4.3.03  update()

                  01. 如果节点调度了更新方法，就会在每帧中收到更新消息；
                  02. 因此，必须在节点类中实现这个更新方法：
                      // override me
                      void Node::update(float fDelta)
                      {
                          // this method is called every frame
                      }
                  03. 非常简单吧？注意，更新方法是有固定格式的，也就是说，它永远是像示例代码这样定义的；
                  04. 参数 fDelta 代码了方法自上次被调用到现在所经过的时间；
                  05. 如果希望每帧调用一次更新方法，以上示例是比较好的做法；
                  06. 但是如果想要有更好的灵活性，最好还是采用其他更新方法。

          4.3.04  selector()

                  4.3.4.01  Calling

                            01. 我们看一下一个例子：
                                void ControlStepper::startAutorepeat()
                                {
                                    _autorepeatCount = -1;
    
                                    this->schedule(schedule_selector(ControlStepper::update),
                                                   kAutorepeatDeltaTime,
                                                   kRepeatForever,
                                                   kAutorepeatDeltaTime * 3);
                                }
                                // Implementation
                                void Scheduler::schedule(SEL_SCHEDULE selector,
                                                         Ref *target,
                                                         float interval,
                                                         unsigned int repeat,
                                                         float delay,
                                                         bool paused)
                                {
                                    // ... ...
                                }
                            02. 这个 C++ 写法有点难我们换成 Objective-C 的方法解释一下，如果想调用另一个方法，
                                或者不想以每帧的频率，而是以每 0.1 秒的频率调用该方法，就应该采用以下做法：
                                [self schedule:@selector(updateTenTimesPerSecond:) interval:0.1f];
                                这会以 0.1 秒的频率向节点发送 updateTenTimesPerSecond 消息：
                                -(void) updateTenTimesPerSecond:(ccTime) delta
                                {
                                    // this method is called according to its interval,
                                    // ten times per second
                                }
                            03. 注意，如果 interval 的值为 0，还是应该用 scheduleUPdate 方法，因为使用
                                scheduleUpdate 调用常用更新选择器时，Cocos2d 对它们做了优化，而其他所有调度
                                的选择器都存储在列表中，并且需要确定彼此的优先级，所以会造成额外的开销，
                                结果就是 scheduleUpdate 方法更快一些；
                            04. 这里的更新方法在格式和原来一样，还是只有参数 "delta"，与之前有所不同的是该更新
                                方法的名称可以根据你的喜好来修改，而且它以 0.1 秒的频率被调用；
                            05. 例如，当游戏逻辑复杂到你不想以每帧的频率去检测玩家是否胜出时，就可以采用这种做法；
                            06. 假如希望在 10 分钟后调用某方法，可以用选择器选定你的更新方法，并把 interval
                                设定为 600；
                            07. 针对每个对象，每个选择器只能被调度一次，超过一次时，Cocos2d 会给出一条警告，
                                指出该选择器已被调度，并且其 interval 已被更新。

                  4.3.4.02  Note in Objective-C

                            01. 我们看到 @selector(…) 语句的时候可能会觉得有些陌生，这在 Objective-C 中用来
                                指定某个特定方法；
                            02. 关键绝不能忘记上述示例中 updateTenTimesPerSecond 后面的冒号！冒号告诉
                                Objective-C：去找一个名为 updateTenTimesPerSecond 的方法，这个方法有且只
                                有一个参数；
                            03. 如果忘记写冒号，编译还是可以通过的，但是程序一运行就会发生崩溃，在 Debugger
                                Console 窗口中，你会看到这个错误日志："unrecongnized selector sent to
                                instance…"
                            04. @selector(…) 中的冒号个数一定要与所指定方法的参数个数相同，假设有下述方法：
                                -(void) example:(ccTime)delta sender:(id)sender flag:(bool)aBool
                            05. 那么，对应的 @selector 语句就应该是：
                                @selector(example:sender:flag:);

          4.3.05  unscheduleAllSelectors()

                  要使节点中所有用选择器选定的方法停止，可使用：
                  this->unscheduleAllSelectors();

          4.3.06  unscheduleUpdate()

                  要使默认的更新方法停止，可使用：
                  this->unscheduleUpdate();

          4.3.07  Stop a Particular Selector

                  要使某个特定选择器选定的方法停止，假设选择器名为 updateTenTimesPerSecond，可使：
                  this->unschedule(schedule_selector(ControlStepper::update));

          4.3.08  Source Code - schedule()

                  4.3.8.01  GameLayer.h

                            void gameLogic(float dt);
                            void addTarget();

                  4.3.8.02  Implementation

                            void GameLayer::gameLogic(float dt)
                            {
                                this->addTarget();
                            }

                            void GameLayer::addTarget()
                            {
                                CCLOG(" ===== Enemy appeared here. =====");
                            }

                  4.3.8.03  GameLayer::init()

                            bool GameLayer::init()
                            {
                                // ... ...
                                // 更新函数
                                this->schedule(schedule_selector(GameLayer::gameLogic), 1.0f);

                                return true;
                            }

                  4.3.8.04  Building, Troubleshooting, Thinking

                            编译，并查看打印信息。

          4.3.09  Source Code - scheduleUpdate()

                  4.3.9.01  GameLayer.h

                            virtual void update(float t);

                  4.3.9.02  Implementation

                            void GameLayer::update(float t)
                            {
                                CCLOG(" ===== Collision detection here. =====");
                            }

                  4.3.9.03  GameLayer::init()

                            bool GameLayer::init()
                            {
                                // ... ...
                                // 更新函数
                                this->scheduleUpdate();

                                return true;
                            }

                  4.3.9.04  Building, Troubleshooting, Thinking

                            编译，并查看打印信息。

          4.3.09  Conclusion

05. Sprite

    5.01  Introduction

          01. Sprite 是 Cocos2d 中最为常用的类，它用一幅图像将精灵显示到屏幕上；
          02. 要创建精灵，最简单的方法就是为精灵指定图像文件，而图像文件会在 Cocos2d 内部被加载到
              Texture2D 类的图像资源中；
          03. 为了保证图像文件能够被成功读取，必须把图像文件加到 Xcode 中的 Resources 分组下，
              否则，应用将无法查到文件（注意还要加载到工程里面）；
          04. Cocos2d 中精灵的定位又有何玄机呢？与一些常见的游戏引擎不同，Cocos2d 中精灵的 position
              属性指定了图像中心所在的位置；
          05. 一个刚被初始化的精灵，它的位置默认为 (0,0)，此时该精灵就会被放置在屏幕左下角，
              因为精灵的 position 属性是指图像中心所在的位置，所以图像只显示其右上角的部分；
          06. 假设图像的大小为 80*30 像素，那么必须把精灵的 position 属性设置为 (40, 15) 才能
              保证图像在屏幕左下角完全显示；
          07. 也许初看起来有些别扭，可是把图像中心作为定位点这个设计确实是非常精妙的，当你使用旋转或缩放
              属性的时候，可以保证精灵的中心点不会发生移动

    5.02  Anchor Points Demystified

    5.03  Conclusion

          01. iOS 设备上的文件名是区分大小写的！而模拟器上的文件名并不区分大小写，所以当你改用真机进行测试时，
              很可能因为文件名而引发程序崩溃；
          02. 这是让很多开发者感到头痛的问题，也是为什么需要经常拿真机进行测试的另一个原因；
          03. 有一种好方法是：设定文件命名规范并严格遵守。

06. LabelTTF

    6.01  Introduction

          LabelTTF 可以帮我们方便地在屏幕上显示文本。

    6.02  Source Code

          Size visibleSize = Director::getInstance()->getVisibleSize();
          Vec2 origin = Director::getInstance()->getVisibleOrigin();

          // add a label shows "Programming is fun."
          // create and initialize a label

          auto label = LabelTTF::create("Programming is fun.", "Arial", 28);

          // position the label on the center of the screen
          label->setPosition(Vec2(origin.x + visibleSize.width/2,
                                  origin.y + label->getContentSize().height));

          // add the label as a child to this layer
          this->addChild(label, 1);

    6.03  Conclusion

          01. Cocos2d 内部会以指定字体作为参数创建 Texture2D 对象，也就是一张纹理，
              然后再由该纹理渲染出最后显示的文本；
          02. 每次文本发生改变，就要做一次上述工作，所以最好不要频繁改变文本，比如说，不要
              每过一帧就改一下文本，重建 LabelTTF 的纹理是非常费时的；
          03. 你还会注意到，标签文本看上去是在标签的位置居中对齐了，在增加或减小标签文本的
              长度时这一点十分明显；
          04. 居中对齐的原因是定位点的默认位置为 (0.5, 0.5)，这使得纹理（本例中标签的文本就是纹理）
              的中心与标签的位置居中对齐；
          05. 很多时候想让文本相对于标签左对齐、右对齐、上对齐或下对齐，只须调用 setLabelAnchorPoint
              方法就可以轻松做到。

07. Menus

    7.01  Introduction

          01. 有时候可能需要提供一些按钮来让用户进入另一个场景，或是关掉背景音乐等；
          02. 这时 MenuItem 类就可以帮上忙了，MenuItem 是 Layer 的子类，并且只能接受
              MenuItem 对象作为其子节点；
          03. 图 The_CCMenuItem_Class_Hierarchy 显示了 MenuItem 类层次体系；
          04. Menu 就是一个 Cocos2d-x 为我们提供的定制的层，这样看来他们其实没有太多的交集，
              但是 MenuItems（注意是带有s复数的）他们必须依赖于 Menu 然后在加载到 Layer 上，
              不然他们不会响应触摸的，Menu 已经帮我们处理好了，我们就开心的用嘛；
          05. Menu 仅仅是一个 MenuItems 的集合，这些菜单项作为菜单的一部分，定义了各种按钮或标签；
              由于 Menu 包含所有的菜单项，所以它控制这些菜单项的对齐方式和位置，在默认情况下，所有的
              菜单项被放置在 Menu 的中心；
          06. Menu 包含如下特点：
              a. 可以在运行时使用 addChild，将 MenuItem 对象到 Menu；
              b. Menu 只接受 MenuItem 对象作为 children。

    7.02  Source Code

          7.2.01  GameLayer.h

                  // a selector callback
                  void menuCloseCallback(cocos2d::Ref* pSender);

          7.2.02  GameLayer.cpp - GameLayer::init()

                  Size visibleSize = Director::getInstance()->getVisibleSize();
                  Vec2 origin = Director::getInstance()->getVisibleOrigin();
                  // add a "close" icon to exit the progress. it's an autorelease object
                  auto closeItem = MenuItemImage::create("CloseNormal.png",
                                                         "CloseSelected.png",
                                                         CC_CALLBACK_1(GameLayer::menuCloseCallback,
                                                         this));
                  closeItem->setPosition(Vec2(origin.x + visibleSize.width -
                                              closeItem->getContentSize().width/2,
                                              origin.y + closeItem->getContentSize().height/2));
    
                  // create menu, it's an autorelease object
                  auto menu = Menu::create(closeItem, NULL);
                  menu->setPosition(Vec2::ZERO);
                  this->addChild(menu, 1);

          7.2.03  GameLayer.cpp - menuCloseCallback()

                  void GameLayer::menuCloseCallback(Ref* pSender)
                  {
                      CCLOG(" ===== CCLOG =====");
                      std::cout << " ----- std::cout -----" << std::endl;
                      Director::getInstance()->end();
                      exit(0);
                  }

    7.03  Menu Items with Blocks

08. Actions

    8.01  Introduction

          01. 动作是轻量级的类，可以用来让节点执行诸如移动、旋转、缩放、变色、消失等很多动作；
          02. 由于它们能作用在所有节点上，因此可以对精灵、标签甚至菜单或整个场景施加动作；
          03. 图 The_CCAction_Class_Hierarchy 显示了 Action 类的层次体系，
              这里没有展开 ActionInterval 和 ActionInstant 的子类；
          04. 只有 3 个动作类直接继承自 Action：
              Follow（允许节点跟踪另一个节点）
              RepeatForever（无限重复某个动作）
              Speed（运行中改变动作刷新频率）
          05. 可以通过使用 Follow 动作类，让一个节点跟随另一个节点，例如，让标签跟随角色精灵；
          06. 通过使用 RepeatForever 可以让动作或整个动作序列永久重复（循环），
              举例这样可以创建无止尽循环动画；
          07. 可以通过 Speed 动作类可以在运行过程中改变动作的速度；
          08. 注意，不能将 Speed 动作添加到 Sequence 动作，因为只能在动作序列中使用继承自
              FiniteTimeAction 的动作类。

    8.02  Interval Actions

          8.2.01  Introduction

                  01. 图 The_ActionInterval_Class_Hierarchy 显示了类 ActionInterval 类
                      的层次体系，此处没有展开 ActionEase 和 GridAction 的子类；
                  02. 由于动作会执行一段时间，比如移动 2 秒钟，代码如下：
                      MoveTo* pMoveTo = MoveTo::create(2, Point(500, 500));
                      pSprite->runAction(pMoveTo);
                  03. 用过这段代码之后你就会发现，pSprite 的运动速度会因为距离不同而不同，
                      同学们练习一下看看移动到 (200, 200) 和 (500, 500) 有什么区别；
                  04. 这个非常常见的问题有如下简单的解决方法：计算当前位置到目的位置的距离，然后用速度
                      去除距离，得到的结果就是正确时间长度，不论当前位置和目的位置在哪儿，都能以同样
                      速度运动到目的位置：
                      Point des = Point(500, 500);
                      float speed = 100;  // in pixels per second
                      float duration = pos.getDistance(des) / speed;
                      MoveTo* pMoveTo = MoveTo::create(duration, des);
                      pSprite->runAction(pMoveTo);
                  05. 顺便提一句，动作是不需要删除的，动作完成之后会自动从节点上清除，并且释放掉自己占用
                      的内存，这不幸也正是动作最大的缺点：你无法重用它们，如果你之后还需要相同的动作或动作
                      序列，就必须重新创建动作类的实例。

          8.2.02  Action Sequences
          
                  01. 当向一个节点添加几个动作时，它们会在同一时间运行，例如，可以通过添加相应的动作让一个
                      节点一边旋转一边消失，但如果想让动作一个接一个运行呢？
                  02. 有时候将动作排成序列会更有用，意思就是一个动作完成之后，下一个动作便开始，而这正是
                      Sequence 的功能，它的功能非常强大，而且经常用到，值得单独提出来介绍；
                  03. 在动作序列中，你可以使用任意数量和类型的动作，例如，将节点移动到目的地，然后旋转一圈，
                      最后再消失，动作是一个接一个运行的，直到整个序列全部完成；
                  04. 下面代码演示如何让标签的颜色从红变成蓝，再变成绿，代码如下：
                      TintTo* pTintTo1 = TintTo::create(3, 255, 0, 0);
                      DelayTime* pWait1 = DelayTime::create(1);
                      TintTo* pTintTo2 = TintTo::create(3, 0, 0, 255);
                      DelayTime* pWait2 = DelayTime::create(1);
                      TintTo* pTintTo3 = TintTo::create(3, 0, 255, 0);
                      Sequence* pSequence = Sequence::create(pTintTo1, pWait1,
                                                             pTintTo2, pWait2,
                                                             pTintTo3, NULL);
                      pSprite->runAction(pSequence);
                  05. 也可以将动作序列和 RepeatForever 动作一起使用，代码如下：
                      Sequence* pSequence = Sequence::create(pTintTo1, pWait1,
                                                             pTintTo2, pWait2,
                                                             pTintTo3, NULL);
                      RepeatForever* pRepeatForever = RepeatForever::create(pSequence);
                      pSprite->runAction(pRepeatForever);
                  06. 还可以很方便地修改重复整个序列的速度，使用 Speed 类，代码如下：
                      Sequence* pSequence = Sequence::create(pTintTo1, pWait1,
                                                             pTintTo2, pWait2,
                                                             pTintTo3, NULL);
                      RepeatForever* pRepeatForever = RepeatForever::create(pSequence);
                      Speed* pSpeed = Speed::create(pRepeatForever, 0.75f);
                      pSprite->runAction(pSpeed);

          8.2.03  Ease Actions
          
                  01. Action Ease 类的出现使得动作显得更为强大，流畅动作允许你改变在一段时间内的动作效果；
                      例如，如果你对一个节点使用 MoveTo，它会匀速移动到目标点，如果使用 ActionEase，
                      就可以让节点由慢到快或由快到慢地移向目标，或是让节点移过目的地一些，再弹回来；
                  02. 看下面这个网页浏览器上运行的 demo 来感受一下流畅动作：
                      www.robertpenner.com/easing/easing_demo.html
                  03. 流畅动作能帮你创建通常要花很长时间才能做出来的动画，下面代码展示了如何使用流畅动作来
                      改变普通动作的行为，rate 参数决定了流畅动画的明显程度，只有当它大于 1 时才能看到效果：
                      // I want myNode to move to 400, 300 and arrive there in 3 seconds
                      MoveTo* pMoveTo = MoveTo::create(3, Point(400, 300));
                      EaseBackInOut* pEaseBackInOut = EaseBackInOut::create(pMoveTo);
                      pSprite->runAction(pEaseBackInOut);
                  04. Cocs2d 实现了如下几个 ActionEase 类：
                      . EaseBackIn, EaseBackInOut, EaseBackOut
                      . EaseBounceIn, EaseBounceInOut, EaseBounceOut
                      . EaseElasticIn, EaseElasticInOut, EaseElasticOut
                      . EaseExponentialIn, EaseExponentialInOut, EaseExponentialOut
                      . EaseIn, EaseInOut, EaseOut
                      . EaseSineIn, EaseSineInOut, EaseSineOut
                  05. 图 The_ActionEase_Class_Hierarchy 显示了类的层次体系。

          8.2.04  Grid Actions
          
                  01. 网格动作是纯视觉动作，派生自 GridAction 及其两个子类 Grid 3DAction 和
                      TiledGrid3DAction，类的层次体系见图：The_Grid3DAction_Class_Hierarchy；
                  02. 网格动作专门用来制作三维效果，例如翻页 (PageTurn3D)，见图：
                      PageTurn3D_Action 和 TiledGrid3DActio_Class_Hierarchy，
                      或者模拟液体波浪和液体流动 (Waves 和 Liquid)；
                  03. 缺点是除非使用深度缓存，否则 3D 效果可能会出现视觉假象，但是深度缓存需要更多的内存，
                      并且对渲染表现力有负面影响；
                  04. 要在 Cocos2d 应用程序中使用深度缓存，需要修改项目 AppDelegate.cpp 文件中初始化
                      GLView 的一行代码；

    8.03  Instant Actions

          8.3.01  Introduction
          
                  01. 瞬时动作基于 InstantAction 类，层次体系如图：ActionInstant_Class_Hierarchy，
                      可用于翻转节点、移动节点以及设置节点的可视属性等；
                  02. 你可能感到奇怪：这些动作都可以通过修改节点属性来完成，那么瞬时动作的存在又有什么意义呢？
                  03. 瞬时动作得以存在的主要原因就是在动作序列中派上了用场，有时你需要改变节点的某个属性，如
                      可视性和位置，然后再继续运行序列，如何在动作序列中修改这些属性呢？这时候瞬时动作就派上
                      用场了；
                  04. 确实，瞬时动作通常只是用于 CallFunc 动作及其变体。

          8.3.02  CallFunc Actions
          
                  01. 使用动作序列时，你也许想在特定时刻收到通知，例如，一个序列完成，紧接着要开始另一个序列，
                      可以使用 CAllFunc 的多个版本来达到这个效果，它们会在序列中轮到自己的时候发出消息；
                  02. 我们重写一下颜色变换序列，它会在每次 TintTo 动作完成后调用一个方法，代码如下：
                      /* GameLayer.cpp */
                      TintTo* pTintTo1 = TintTo::create(3, 255, 0, 0);
                      TintTo* pTintTo2 = TintTo::create(3, 0, 0, 255);
                      auto action1 = CallFunc::create(std::bind(&GameLayer::onCallFunc, this));
                      auto action2 = CallFuncN::create(std::bind(&GameLayer::onCallFuncN, this));
                      Sequence* pSequence = Sequence::create(pTintTo1, action1,
                                           pTintTo2, action2, NULL);
                      pSprite->runAction(pSequence);
                      void GameLayer::onCallFunc()
                      {
                          CCLOG(" ==== onCallFun() called. ==== ");
                      }
                      void GameLayer::onCallFuncN()
                      {
                          CCLOG(" ==== onCallFunN() called. ==== ");
                      }
                      /* GameLayer.h */
                      void onCallFunc();
                      void onCallFuncN();
                  03. 当然，CAllFunc 动作也能和 RepeatForever 序列配合使用，你的方法会在适当的时候被反复调用，
                      结合 RepeatForever 的同学们现在练习一下。

          8.3.03  CallBlock Actions

09. Orientation, Singletons, Tests, and API References

    9.01  Introduction
    
          01. 这一节总结了 Cocos2d 中没有受到足够重视的 3 方面内容，以及受到重视或许过多的单例械；
          02. 单例被指出来在实践中效果并不好，甚至有的开发者指出所有的项目都不应该用到单例；
          03. 尽管如此，像我这样的实用主义者，还没有见过什么游戏引擎或游戏项目不使用单例，这一定有其原因的；
          04. 之后还有一些 Cocos2d 测试案例和 API 参考，这些都是帮你解答疑惑的很有用资源，只要你知道在哪
              里能找到就行了。

    9.02  Orientation Course in Device Orientation
    
          01. 多多少少你会想要把应用程序固定在 4 个方向可能设备方向中的一个上，或者至少固定在 Landscape
              与 Portrait 模式两者之一；
          02. 系统会经常询问下面的方法，确定是否允许将应用程序自动旋转到特定的界面方向：
              // Override to allow orientations other than the default portrait orientation.
              // This method is deprecated on ios6
              - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
              {
                      return UIInterfaceOrientationIsLandscape( interfaceOrientation );
              }
          03. 如果应用程序支持参数传递的对应方向，那么该方法应该返回 YES，否则返回 NO，至少要在一个界面方向
              上返回 YES，否则 iOS 默认为 Portrait 模式；
          04. 建议你允许应用程序可以旋转至两个 Landscape 方向或两个 Portrait 方向，因为有的用户喜欢 Home
              键在左边，而有的却喜欢在或边，因此，应该昼将决定权留给用户；
          05. 极少数情况下，你可能想支持 4 个方向，只要在 shouldAutorotateToInterfaceOrientation
              方法中返回 YES 就行。

    9.03  Singletons in Cocos2d
    
          9.3.01  Introduction
          
                  01. Cocos2d 充分利用了单例 (singletons) 设计模式，这也常常成为开发者热议的话题，从理论
                      上讲，单例就是普通的类，但单例在应用程序的整个生命周期中只被实例化一次；
                  02. 为了确保这一点，Cocos2d 采用静态方法来创建并访问这个对象实例，所以要访问单例对象，不应
                      使用 malloc/free 或静态的自动释放初始化方法，而应该用以 shared 开头的方法。
          
          9.3.02  Singletons Examples

                  01. Scheduler, ActionManager 和 TouchDispatcher 都可以像 Director 那样访问；
                  02. Cocos2d 中的 4 个高速缓存类也实现为单例类：AnimationCache, ShaderCache,
                      SpriteFrameCache, TextureCache；
                  03. 还有一些很少用到的单例 Configuration, Profiler；
                  04. CocsDenshion 声音引擎还提供了两个单例类，AudioManger 及早其相似类 SimpleAudioEngine。
          
          9.3.03  Advantage
          
                  01. 单例的好处在于可以在任何地方被任何类使用，可以将之理解为全局类，如果在很多不同的地方需要使用
                      一组数据和方法，那么这时候单就非常有用；
                  02. 缓存和音频就是很好的示例，因为任何类（无论是玩家类、敌方类、菜单类或过场动画类）都可能需要
                      播放音效或切换背景音乐，所以选择用单例来播放音频是明智之举；与
                  03. 此类似，你可能希望将全局的游戏
                      信息（可能是玩家持有的兵器数目，也可能是军队有多少人，等等）存储在单例中，这样就可以在游戏的
                      不同关卡中使用同一份数据了。
          
          9.3.04  Disadvantage

                  01. 不过，单例也有缺点，正因为它们易于实现、方便使用，而且可以在其他任何类中使用，所以人们经常
                      会过度使用它们，就像全局变量一样，大多数程序员认为应该少用并且慎重使用；
                  02. 例如，你可能想：我只有一个玩家对象，为什么不把这个玩家类设为单例呢？这种想法似乎完美，但你
                      会突然发现，只要玩家进入下一个关卡，他就不仅带着上一轮的分数，而且还保持着上一轮最后的动作、
                      血量、捡到的所有道具；甚至，他刚进入下一关就已经在 "狂暴" (Berserk Mode) 模式下了，而这
                      恰恰是因为他离开上一关的时候就处于这个模式；
                  03. 为了解决这个问题，你会添加几个方法，在关卡发生变化时对一些变量进行重置，到目前为止，一切都
                      进行的很顺利，但是你为游戏设计更多特性时，你会发现转换关卡时需要添加很多变量，而且还要对很
                      多已有变量进行维护；更糟糕的是，假如有一天朋友建议你为 iPad 版本添加双人模式，这时候你想
                      起玩家是个单例！任何时候都只能有一个玩家实例！于是你将面临一个非常令人头疼的问题：要么重写
                      大量代码进行彻底重构，要么放弃双人模式；
                  04. 或者为什么不给第二个玩家再创建一个单例呢？第二玩家什么时候需要第一玩家的信息时，直接用第一
                      玩家的单例就行了，这样一来他们之间保持互相的引用，这也就意味着不初始化另一个玩家时没法进行
                      单人游戏；这种作法的副作用之一就是过分互相依赖，也称作紧密连接 (tight coupling)，越多的
                      类之间紧密连接，就越难修改代码，就像是和水泥，等慢慢变干变硬，以至于修改起来增加代码比改进
                      代码要容易；这也是会随机出现各种 bug 的地方，而且和所做的修改没有联系，总而言之，令人沮丧。
                  05. 越是依赖于单例，就会碰到越多这样的麻烦事，所以在你创建单例类之间，务必考虑清楚，对于这个类
                      以及数据，是否真的只需要一个实例？这个设计以后是否会发生变化？

          9.3.05  Conclusion
          
                  01. 我知道对于初学者来说，很难判断什么地方什么时候该用单例，特别是如果你没有一定的面向对象编程
                      经验的话就更难了；
                  02. 建议你学习单例的流行用法，Cocos2d 游戏引擎中用于资源管理的单例是完全可
                      行的，因为它简化了游戏引擎的整体设计，很多其他的游戏引擎也用单例达到相似的目的，我也没听过
                      有什么抱怨，你甚至还能在 iOS SDK 中找到单例，尽管由于引入强依赖性，他们确实会变得问题百出，
                      而且随着代码量的增长，问题也会成倍加剧，但一般来说单例还是没有人们说的那么差。

    9.04  Cocos2d Test Cases
    
          01. Cocos2d 自带了许多样例代码，其中包含了许多测试目标程序，你可以生成并运行，你能看到这些项目的工作
              方式，也可以查看代码的具体实现，这些测试样例是在引擎开发过程中为测试引擎的正确性而编写的代码，
              同时也是演示引擎各个部分如何使用的良好示例；
          02. 打开 Cocos2d-x 根目录下 build 文件夹下的 cocos2d_tests.xcodeproj 解决方案，设置其中的 
              cpp-tests 项目为启动项目，成功运行后，就能够看到许多引擎特性的效果演示了；
          03. 这个项目的代码展示了 Cocos2d-x 引擎的很多标准用法，几乎涵盖了引擎的全部功能，非常具有参考价值；
          04. 但是我也有些犹豫要不要推荐这些测试案例，因为其中包含了大量的非标准代码，有些测试可以说是非常马虎，
              毕竟这些代码都只是用来测试代码工作的，不是用来做高级代码教学的，所以自己学习这些测试代码的时候注意
              去粗取精吧；
          05.尽管如此，这些测试案案例几乎说明了 Cocos2d 的所有特征，可以每个都运行一下，看看里面有什么，或者至少
             运行一遍那些你感兴趣的部分；例如，测试案例展示了所有 Cocos2d 支持的动作，包括 3D 动作中的涟漪、波浪
             和翻页效果。

    9.05  Cocos2d API Reference
    
          01. Cocos2d API 参考描述了 Cocos2d 中所有的类、方法以及属性，例如可以找到一个类所能支持的各种初始化
              方法，或者它所拥有的属性，这些都很有用，这些有价值的信息能帮助你提前规划好代码；
          02. 当有类似 "我能用 y 类做 x 事情吗？" 这样的问题时，就应该查阅 API 参考，找到 y 类，然后查看对你有
              用的属性和方法；
          03. 网址为：http://www.cocos2d-x.org/wiki/Reference。

10. Conclusion

11. Homework

    11.01  做一个拳皇 97 的出场动画。

    11.02  在前一个拳皇 97 的出场动画的基础上，再点下一步的一个菜单然后出现双方人物的属性。

12. Traps and Pitfalls

    12.01  Cannot Reuse Action
    
           01. 我在 Cocos2d 文档中看到一条建议，说将动作发送至合适的 initWith... 消息就可以再次初始
               化动作；
           02. 但这是危险的，会导致内存泄漏甚至可能崩溃，因为不是每一个动作类都可以被安全地重新初始化，
               对于有些动作，就没有这个效果；
           03. 如果保留指向某个动作的指针，那么你可能是想一会儿重用这个动作，于是将它多次作为参数传给
               runAction，你会发现要么动作没有任何效果，要么就是执行不正常，表现这个问题最简单的方法
               就是在两个不同的节点上尝试相同的动作，比如：
               // 创建一个精灵
               pSprite = Sprite::create("Battleplane.png");
               pPlayer = Sprite::create("Plane.png");
               // Point 对象代表一个点（或者向量）
               Point pos = Point(100, 100);
               // 设置精灵的坐标
               pSprite->setPosition(pos);
               pPlayer->setPosition(Point(300, 300));
               // 将精灵添加至图层当中
               this->addChild(pSprite);
               this->addChild(pPlayer);

               MoveTo* pMoveTo = MoveTo::create(2, Point(200, 200));
               pSprite->runAction(pMoveTo);
               pPlayer->runAction(pMoveTo);
           04. 只有 pPlayer 执行了动作，因为它是最后一个使用这个动作的节点，动作只在单个节点上有效，
               因此 pSprite 根本就不会移动，如果你想让两个节点都移动，只有创建两个 MoveTo 类实例，
               真的没有其他办法了。
               
    12.02  Sequence
           
           01. 就像使用菜单项那样，一串动作总是以 NULL 结尾；
           02. 如果你忘记在最后那个参数位置加上 NULL，创建 Sequence 的这行代码就会崩溃。
           
    12.03  runAction
    
           01. 当你使用动作时，很容易忘记修改 runAction 那行代码，即使是最有经验的 Cocos2d 开发者也
               会犯这样的错误；
           02. 如果发现动作并未像预期那样执行，仔细检查下你是否执行了正确的动作；
           03. 如果执行的的确是正确的动作，但依然没看到期望的结果，就再检查下运行的节点是否正确；
               这又是另一个常见的错误。
               
    12.04  Scenes and Memory
    
           01. 当场景进行切换时，Cocos2d 会把自己占用的内存清理干净，它会删去所有节点，停止所有动作，并对
               所有用选择器选中的方法取消调度；
           02. 之所以提出这个问题，是因为有时我看到一些开发者直接调用 Cocos2d 的 removeAll 和 cleanup 方法，
               其实这是没有必要的，应该信任 Cocos2d 的内存管理能力。
               
    12.05  Pushing and Popping Scenes
    
           01. 使用 SceneTransition 类只能使 pushScene 调用以动画形式显示，而不能使 popScene 以动画形式
               显示；
           02. 这是推进和弹出场景的一个缺点，使用时应该注意。
           
    12.06  TransitionsScene
    
           01. 并不是所有过滤效果都很有用，虽然它们看起来很优雅，但玩家最在乎的还是过滤的速度，哪怕只有两秒，
               对玩空来说都是难以忍受的；
           02. 我喜欢在一秒内完成过滤，或者在适当的情况下干脆不使用过滤效果；
           03. 切忌在场景转换时采用随机过渡效果，同样身为游戏开发者，我能够理解你做了华丽的过渡效果时有多么兴奋，
               但是玩家并不在乎这些；
           04. 如果你不确定用哪种过滤效果好，干脆别用了，要知道，"可以" 使用过渡效果并不意味着你非得去用它。

13. Diligence

    13.01  Log
    
           01. 向场景或创建场景的层中添加日志记录语句是一个非常好的习惯，注意观察这些日志消息，如果发现在进行场景
               切换时 free 日志消息从来没有显示出来，这是一个巨大的预警信号；
           02. 这意味着整个场景都没有从内存中释放，发生了泄露；
           03. 记住，绝对不要把节点添加为场景图的子节点，然后将这个节点传递给另一个会保留该节点引用的节点；
           04. 可以用 Cocos2d 提供的方法来获取这些节点对象，只要把内存管理的问题丢给 Cocos2d，你就是安全的。
    
    13.02